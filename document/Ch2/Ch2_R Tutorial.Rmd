---
title: "R 语言教程"
author: "Author: Shane"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`" 
output: 
  pdf_document: 
    toc: yes
    latex_engine: xelatex
  word_document: default
  html_document:     
    self_contained: false
    toc: true
    toc_float:
        collapsed: true
        smooth_scroll: true
    toc_depth: 3
    fig_caption: yes
    code_folding: show
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(# warning = FALSE, 
                      message = FALSE,
                      echo = TRUE)
```

# 常量与变量 {#C1}

## 常量

R 语言基本的数据类型有数值型，逻辑型（TRUE, FALSE），文本（字符串）。支持缺失值，有专门的复数类型。

常量是指直接写在程序中的值。

数值型常量包括整型、单精度、双精度等，一般不需要区分。写法如 123, 123.45, -123.45, -0.012, 1.23E2, -1.2E-2 等。为了表示 123 是整型，可以写成123L。

字符型常量用两个双撇号或两个单撇号包围，如"Li Ming" 或'Li Ming'。字符型支持中文，如" 李明" 或' 李明'。国内的中文编码主要有 GBK 编码和UTF-8 编码，有时会遇到编码错误造成乱码的问题，MS Windows 下 R 程序一般用 GBK 编码，但是 RStudio 软件采用 UTF-8 编码。在 R 软件内字符串一般用 UTF-8 编码保存。

逻辑型常量只有 TRUE 和 FALSE。

缺失值用 NA 表示。统计计算中经常会遇到缺失值，表示记录丢失、因为错误而不能用、节假日没有数据等。除了数值型，逻辑型和字符型也可以有缺失值，
而且字符型的空白值不会自动辨识为缺失值，需要自己规定。R 支持特殊的 Inf值，这是实数型值，表示正无穷大，不算缺失值。

复数常量写法如 2.2 + 3.5i, 1i 等。

## 变量

程序语言中的变量用来保存输入的值或者计算得到的值。在 R 中，变量可以保存所有的数据类型，比如标量、向量、矩阵、数据框、函数等。

变量都有变量名，R 变量名必须以字母、数字、下划线和句点组成，变量名的第一个字符不能取为数字。在中文环境下，汉字也可以作为变量名的合法字符
使用。变量名是区分大小写的，y 和 Y 是两个不同的变量名。

变量名举例: x, x1, X, cancer.tab, clean_data, diseaseData。

用 <-赋值的方法定义变量。<-也可以写成 =，但是 <-更直观。如


```{r}
x5 <- 6.25 
x6 = sqrt(x5)
```

R 的变量没有固定的类型，给已有变量赋值为新的类型，该变量就变成新的类
型，但一般应避免这样的行为。R 是 “动态类型” 语言，赋值实际上是 “绑定” （binding），即将一个变量名与一个存储地址联系在一起，同一个存储地址可以有多个变量名与其联系。

## R 数据类型

R 语言基本的数据类型有数值，逻辑型（TRUE, FALSE），文本（字符串）。支持缺失值，有专门的复数类型。

R 语言数据结构包括向量，矩阵和数据框，多维数组，列表，对象等。数据中元素、行、列还可以用名字访问。最基本的是向量类型。向量类型数据的访问方式也是其他数据类型访问方式的基础。

# 数值型向量及其运算

## 数值型向量

**向量**是将若干个基础类型相同的值存储在一起，各个元素可以按序号访问。如果将若干个数值存储在一起可以用序号访问，就叫做一个数值型向量。

用 c() 函数把多个元素或向量组合成一个向量。如

```{r}
marks <- c(10, 6, 4, 7, 8) 
x <- c(1:3, 10:13)
x1 <- c(1, 2)
x2 <- c(3, 4)
x <- c(x1, x2)
x
```

10:13 这样的写法表示从 10 到 13 的整数组成的向量。

用 print() 函数显示向量或在命令行中显示向量时，每行显示的行首会有方括号和数字序号，代表该行显示的第一个向量元素的下标。如

```{r}
12345678901:12345678920
```

length(x) 可以求x 的长度。长度为零的向量表示为 numeric(0)。numeric()
函数可以用来初始化一个指定元素个数而元素都等于零的数值型向量，如
numeric(10) 会生成元素为 10 个零的向量。

## 向量运算

### 标量和标量运算

单个数值称为**标量**，R 没有单独的标量类型，标量实际是长度为 1 的向量。
R 中四则运算用 + - * / ˆ 表示 (加、减、乘、除、乘方)，如

```{r}
1.5 + 2.3 - 0.6 + 2.1*1.2 - 1.5/0.5 + 2^3
```

R 中四则运算仍遵从通常的优先级规则，可以用圆括号 () 改变运算的先后次序。如

```{r}
1.5 + 2.3 - (0.6 + 2.1)*1.2 - 1.5/0.5 + 2^3
```

除了加、减、乘、除、乘方，R 还支持整除运算和求余运算。用%/% 表示整除，用%% 表示求余。如

```{r}
5 %/% 3
5 %% 3
5.1 %/% 2.5
5.1 %% 2.5
```

### 向量与标量运算

向量与标量的运算为每个元素与标量的运算, 如

```{r}
x <- c(1, 10) 
x + 2
x - 2
x * 2
x / 2
x ^ 2
2 / x
2 ^ x
```

一个向量乘以一个标量，就是线性代数中的数乘运算。

四则运算时如果有缺失值，缺失元素参加的运算相应结果元素仍缺失。如

```{r}
c(1, NA, 3) + 10
```

### 等长向量运算

等长向量的运算为对应元素两两运算。如

```{r}
x1 <- c(1, 10) 
x2 <- c(4, 2) 
x1 + x2
x1 - x2
x1 * x2
x1 / x2
```

两个等长向量的加、减运算就是线性代数中两个向量的加、减运算。

### 不等长向量的运算

两个不等长向量的四则运算，如果其长度为倍数关系，规则是每次从头重复利用短的一个。如

```{r}
x1 <- c(10, 20) 
x2 <- c(1, 3, 5, 7) 
x1 + x2
x1 * x2
```

不仅是四则运算，R 中有两个或多个向量按照元素一一对应参与某种运算或函数调用时，如果向量长度不同，一般都采用这样的规则。

如果两个向量的长度不是倍数关系，会给出警告信息。如

```{r}
c(1,2) + c(1,2,3)
```

## 向量函数

### 向量化的函数

R 中的函数一般都是向量化的: 在 R 中，如果普通的一元函数以向量为自变量，
一般会对每个元素计算。这样的函数包括 sqrt, log10, log, exp, sin, cos, tan
等许多。如

```{r}
sqrt(c(1, 4, 6.25))
```

为了查看这些基础的数学函数的列表，运行命令 help.start()，点击链接 “Search Engine and Keywords”，找到 “Mathematics” 栏目，浏览其中的 “arith” 和 “math” 链接中的说明。常用的数学函数有：

- 舍入：ceiling, floor, round, signif, trunc, zapsmall
- 符号函数 sign
- 绝对值 abs
- 平方根 sqrt
- 对数与指数函数 log, exp, log10, log2
-	三角函数 sin, cos, tan
-	反三角函数 asin, acos, atan, atan2
-	双曲函数 sinh, cosh, tanh
-	反双曲函数 asinh, acosh, atanh

有一些不太常用的数学函数：

- 贝塔函数 beta, lbeta
-	伽玛函数 gamma, lgamma, digamma, trigamma, tetragamma, pentagamma
-	组合数 choose, lchoose
-	富利叶变换和卷积 fft, mvfft, convolve
-	正交多项式 poly
-	求根 polyroot, uniroot
-	最优化 optimize, optim
-	Bessel 函数 besselI, besselK, besselJ, besselY
-	样条插值 spline, splinefun
-	简单的微分 deriv

如果自己编写的函数没有考虑向量化问题，可以用 Vectorize() 函数将其转换成向量化版本。

### 排序函数

sort(x) 返回排序结果。rev(x) 返回把各元素排列次序反转后的结果。 order(x) 返回排序用的下标。如

```{r}
x <- c(33, 55, 11) 
sort(x)
rev(sort(x))
order(x)
x[order(x)]
```

例子中，order(x) 结果中 3 是 x 的最小元素 11 所在的位置下标，1 是 x 的第二小元素 33 所在的位置下标，2 是 x 的最大元素 55 所在的位置下标。

### 统计函数

sum(求和), mean(求平均值), var(求样本方差), sd(求样本标准差), min(求最小值), max(求最大值), range(求最小值和最大值) 等函数称为统计函数，把输入向量看作样本，计算样本统计量。prod 求所有元素的乘积。

cumsum 和 cumprod 计算累加和累乘积。如

```{r}
cumsum(1:5)
cumprod(1:5)
```

其它一些类似函数有 pmax, pmin, cummax, cummin 等。

### 生成规则序列的函数

seq 函数是冒号运算符的推广。比如，seq(5) 等同于 1:5。seq(2,5) 等同于2:5。seq(11, 15, by=2) 产生 11,13,15。seq(0, 2*pi, length.out=100)产生从 0 到 2π 的等间隔序列，序列长度指定为 100。

从这些例子可以看出，S 函数可以带自变量名调用。每个函数的变量名和用法可以查询其帮助信息，在命令行界面用 “? 函数名” 的方法查询。在使用变量名时次序可以颠倒，比如 seq(to=5, from=2)} 仍等同于 2:5。

rep() 函数用来产生重复数值。为了产生一个初值为零的长度为 n 的向量，用x <- rep(0, n)。rep(c(1,3), 2) 把第一个自变量重复两次，结果相当于c(1,3,1,3)。

rep(c(1,3), c(2,4)) 则需要利用 R 的一般向量化规则，把第一自变量的第一个元素 1 按照第二自变量中第一个元素 2 的次数重复，把第一自变量中第二个元素 3 按照第二自变量中第二个元素 4 的次数重复，结果相当于c(1,1,3,3,3,3)。

如果希望重复完一个元素后再重复另一元素，用 each= 选项，比如rep(c(1,3), each=2) 结果相当于 c(1,1,3,3)。

## 复数向量

复数常数表示如 3.5+2.4i, 1i。用函数 complex() 生成复数向量，指定实部和虚部。如 complex(c(1,0,-1,0), c(0,1,0,-1))} 相当于 c(1+0i, 1i, -1+0i, -1i)。

在 complex() 中可以用 mod 和 arg 指定模和辐角，如 complex(mod=1, arg=(0:3)/2*pi) 结果同上。

用 Re(z) 求 z 的实部，用 Im(z) 求 z 的虚部，用 Mod(z) 或 abs(z) 求 z的模，用 Arg(z) 求 z 的辐角，用 Conj(z) 求 z 的共轭。

sqrt, log, exp, sin 等函数对复数也有定义，但是函数定义域在自变量为实数时可能有限制而复数无限制，这时需要区分自变量类型。如

```{r, eval=FALSE}
sqrt(-1)
## [1] NaN
## Warning message:
## In sqrt(-1) : NaNs produced sqrt(-1 + 0i)
## [1] 0+1i
```

## 练习

1.	显示 1 到 100 的整数的平方根和立方根（提示：立方根就是三分之一次方）。
2.	设有 10 个人的小测验成绩为: 77 60 91 73 85 82 35 100 66 75
    (1)	把这 10 个成绩存入变量 x;
    (2)	从小到大排序；
    (3)	计算 order(x)，解释 order(x) 结果中第 3 项代表的意义。
    (4)	计算这些成绩的平均值、标准差、最小值、最大值、中位数。
3.  生成 [0, 1] 区间上等间隔的 100 个格子点存入变量 x 中。
  
#  逻辑型向量及其运算

## 逻辑型向量与比较运算

逻辑型是 R 的基本数据类型之一，只有两个值 TRUE 和 FALSE, 缺失时为NA。逻辑值一般产生自比较，如

```{r}
sele <- (log10(15) < 2); print(sele)
```

向量比较结果为逻辑型向量。如

```{r}
c(1, 3, 5) > 2
(1:4) >= (4:1)
```

从例子可以看出，向量比较也遵从 R 的向量间运算的一般规则：向量与标量的运算是向量每个元素与标量都分别运算一次，等长向量的运算时对应元素的运算，不等长但长度为倍数关系的向量运算是把短的从头重复利用。

与 NA 比较产生 NA，如

```{r}
c(1, NA, 3) > 2
NA == NA
```

为了判断向量每个元素是否 NA，用 is.na() 函数，如

```{r}
is.na(c(1, NA, 3) > 2)
```

用 is.finite() 判断向量每个元素是否 Inf 值。

比较运算符包括

< <= > >= == != %in%

分别表示小于、小于等于、大于、大于等于、等于、不等于、属于。要注意等于比较用了两个等号。

%in% 是比较特殊的比较，x %in% y 的运算把向量 y 看成集合，运算结果是一个逻辑型向量，第 i 个元素的值为 x 的第 i 元素是否属于 y 的逻辑型值。如

```{r}
c(1,3) %in% c(2,3,4)
c(NA,3) %in% c(2,3,4)
c(1,3) %in% c(NA, 3, 4)
c(NA,3) %in% c(NA, 3, 4)
```

函数 match(x, y) 起到和 x %in% y 运算类似的作用，但是其返回结果不是找到与否，而是对 x 的每个元素，找到其在 y 中首次出现的下标，找不到时取缺失值，如

```{r}
match(c(1, 3), c(2,3,4,3))
```

## 逻辑运算

为了表达如 “x > 0 而且 x < 1”, “x ≤ 0 或者 x ≥ 1” 之类的复合比较，需要使用逻辑运算把两个比较连接起来。逻辑运算符为 &, | 和!, 分别表示 “同时成立”、“两者至少其一成立”、“条件的反面”。比如，设 age<=3 表示婴儿，sex==' 女' 表示女性，则 age<=3 & sex==' 女' 表示女婴, age<=3 | sex==' 女' 表示婴儿或妇女, !(age<=3 | sex==' 女') 表示既非婴儿也非妇女。为了确定运算的先后次序可以用圆括号 () 指定。

用 xor(x, y) 表示 x 与 y 的异或运算，即值不相等时为真值，相等时为假值，有缺失值参加运算时为缺失值。

逻辑向量与逻辑标量之间的逻辑运算，两个逻辑向量之间的逻辑运算规则遵从一般 R 向量间运算规则。

在右运算符是缺失值时，如果左运算符能够确定结果真假，可以得到非缺失的结果。例如，TRUE | NA 为 TRUE, FALSE & NA 为 FALSE。不能确定结果时返回 NA，比如，TRUE & NA 为 NA, FALSE | NA 为 NA。

&& 和 || 分别为短路的标量逻辑与和短路的标量逻辑或，仅对两个标量进行运算，如果有向量也仅使用第一个元素。一般用在 if 语句、while 语句中，且只要第一个比较已经决定最终结果就不计算第二个比较。例如

```{r, eval=FALSE}
if(TRUE || sqrt(-1)>0) next
```

其中的 sqrt(-1) 部分不会执行。
这里结果为 TRUE, 第二部分没有参加计算，否则第二部分的计算会发生函数自变量范围错误。

## 逻辑运算函数

因为 R 中比较与逻辑运算都支持向量之间、向量与标量之间的运算，所以在需要一个标量结果时要特别注意，后面讲到的 if 结构、while 结构都需要逻辑标量而且不能是缺失值。这时，应该对缺失值结果单独考虑。

若 cond 是逻辑向量，用 all(cond) 测试 cond 的所有元素为真；用any(cond) 测试 cond 至少一个元素为真。cond 中允许有缺失值，结果可能为缺失值。如

```{r}
c(1, NA, 3) > 2
all(c(1, NA, 3) > 2)
any(c(1, NA, 3) > 2)
all(NA)
any(NA)
```

函数 which() 返回真值对应的所有下标，如

```{r}
which(c(FALSE, TRUE, TRUE, FALSE, NA))
which((11:15) > 12)
```

函数 identical(x,y) 比较两个 R 对象 x 与 y 的内容是否完全相同，结果只会取标量 TRUE 与 FALSE 两种。如

```{r}
identical(c(1,2,3), c(1,2,NA))
identical(c(1L,2L,3L), c(1,2,3))
```

其中第二个结果假值是因为前一向量是整数型，后一向量是实数型。

函数 all.equal() 与 identical() 类似，但是在比较数值型时不区分整数型与实数型，而且相同时返回标量 TRUE，但是不同时会返回一个说明有何不同的字符串。如

```{r}
all.equal(c(1,2,3), c(1,2,NA))
all.equal(c(1L,2L,3L), c(1,2,3))
```

函数 duplicated() 返回每个元素是否为重复值的结果，如：

```{r}
duplicated(c(1,2,1,3,NA,4,NA))
```

用函数 unique() 可以返回去掉重复值的结果。

# 字符型数据及其处理

## 字符型向量

字符型向量是元素为字符串的向量。如

```{r}
s1 <- c('abc', '', 'a cat', NA, ' 李明')
```

注意空字符串并不能自动认为是缺失值，字符型的缺失值仍用 NA 表示。

## paste() 函数

针对字符型数据最常用的 R 函数是 paste() 函数。paste() 用来连接两个字符型向量，元素一一对应连接，默认用空格连接。如 paste(c("ab", "cd"), c("ef", "gh")) 结果相当于 c("ab ef", "cd gh")。

paste() 在连接两个字符型向量时采用 R 的一般向量间运算规则，而且可以自动把数值型向量转换为字符型向量。可以作一对多连接，如 paste("x", 1:3)结果相当于 c("x 1", "x 2", "x 3")。

用 sep= 指定分隔符，如 paste("x", 1:3, sep="") 结果相当于 c("x1", "x2", "x3")。

使用 collapse= 参数可以把字符型向量的各个元素连接成一个单一的字符串,如 paste(c("a", "b", "c"), collapse="") 结果相当于"abc"。

## 转换大小写

toupper() 函数把字符型向量内容转为大写，tolower() 函数转为小写。比如， toupper('aB cd') 结果为"AB CD"，tolower(c('aB', 'cd')) 结果相当于c("ab" "cd")。这两个函数可以用于不区分大小写的比较，比如，不论 x 的值是'JAN', 'Jan' 还是'jan'，toupper(x)=='JAN' 的结果都为 TRUE。

## 字符串长度

用 nchar(x, type='bytes') 计算字符型向量 x 中每个字符串的以字节为单位的长度，这一点对中英文是有差别的，中文通常一个汉字占两个字节，英文
字母、数字、标点占一个字节。用 nchar(x, type='chars') 计算字符型向量 x 中每个字符串的以字符个数为单位的长度，这时一个汉字算一个单位。

在画图时可以用 strwidth() 函数计算某个字符串或表达式占用的空间大小。

## 取子串

substr(x, start, stop) 从字符串 x 中取出从第 start 个到第 stop 个的子串，如

```{r}
substr('JAN07', 1, 3)
```

如果 x 是一个字符型向量，substr 将对每个元素取子串。如

```{r}
substr(c('JAN07', 'MAR66'), 1, 3)
```

用 substring(x, start) 可以从字符串 x 中取出从第 start 个到末尾的子串。如

substring(c('JAN07', 'MAR66'), 4)

## 类型转换

用 as.numeric() 把内容是数字的字符型值转换为数值，如

```{r, eval=FALSE}
substr('JAN07', 4, 5)
## [1] "07"
substr('JAN07', 4, 5) + 2000
## Error in substr("JAN07", 4, 5) + 2000 : 
## non-numeric argument to binary operator 
as.numeric(substr('JAN07', 4, 5)) + 2000
## [1] 2007
as.numeric(substr(c('JAN07', 'MAR66'), 4, 5)) 
## [1] 7 66
```

as.numeric() 是向量化的，可以转换一个向量的每个元素为数值型。用 as.character() 函数把数值型转换为字符型，如

```{r}
as.character((1:5)*5)
```

如果自变量本来已经是字符型则结果不变。

为了用指定的格式数值型转换成字符型，可以使用 sprintf() 函数，其用法与C 语言的 sprintf() 函数相似，只不过是向量化的。例如

```{r}
sprintf('file%03d.txt', c(1, 99, 100))
```

## 字符串拆分

用 strsplit() 函数可以把一个字符串按照某种分隔符拆分开，例如

```{r}
x <- '10,8,7'
strsplit(x, ',', fixed=TRUE)[[1]]
sum(as.numeric(strsplit(x, ',', fixed=TRUE)[[1]]))
```

因为 strsplit() 的结果是一个列表，这个函数延后再详细讲。

## 字符串替换功能

用 gsub() 可以替换字符串中的子串，这样的功能经常用在数据清理中。比如，把数据中的中文标点改为英文标点，去掉空格，等等。如

```{r}
x <- '1, 3; 5'
gsub(';', ',', x, fixed=TRUE)
strsplit(gsub(';', ',', x, fixed=TRUE), ',')[[1]]
```

字符串 x 中分隔符既有逗号又有分号，上面的程序用 gsub() 把分号都换成逗号。
更多的文本数据（字符型数据）功能参见35。

## 正则表达式

正则表达式 (regular expression) 是一种匹配某种字符串模式的方法。用这样的方法，可以从字符串中查找某种模式的出现位置，替换某种模式，等等。这样的技术可以用于文本数据的预处理，比如用网络爬虫下载的大量网页文本数据。R 中支持 perl 语言格式的正则表达式，grep() 和 grepl() 函数从字符串中查询某个模式，sub() 和 gsub() 替换某模式。比如，下面的程序把多于一个空格替换成一个空格

```{r}
gsub('[[:space:]]+', '', 'a cat in a box', perl=TRUE)
```

正则表达式功能强大但也不容易掌握。

# R 向量下标和子集

在 R 中下标与子集是极为强大的功能，需要一些练习才能熟练掌握，许多其它语言中需要多个语句才能完成的工作在 R 中都可以简单地通过下标和子集来完成。

## 正整数下标

对向量 x, 在后面加方括号和下标可以访问向量的元素和子集。

设 x <- c(1, 4, 6.25)。x[2] 取出第二个元素；x[2] <- 99 修改第二个元素。x[c(1,3)] 取出第 1、3 号元素；x[c(1,3)] <- c(11, 13) 修改第 1、3号元素。下标可重复。例如

```{r}
x <- c(1, 4, 6.25) 
x[2]
x[2] <- 99; x
x[c(1,3)]
x[c(1,3)] <- c(11, 13); x
x[c(1,3,1)]
```

## 负整数下标

负下标表示扣除相应的元素后的子集，如

```{r}
x <- c(1,4,6.25) 
x[-2]
x[-c(1,3)]
```

负整数下标不能与正整数下标同时用来从某一向量中取子集，比如，x[c(1,-2)]没有意义。

## 空下标与零下标

x[] 表示取 x 的全部元素作为子集。这与 x 本身不同，比如

```{r}
x <- c(1,4,6.25) 
x[] <- 999
x
x <- c(1,4,6.25) 
x <- 999
x
```

x[0] 是一种少见的做法，结果返回类型相同、长度为零的向量，如 numeric(0)。相当于空集。

当 0 与正整数下标一起使用时会被忽略。当 0 与负整数下标一起使用时也会被忽略。

## 下标超界

设向量 x 长度为 n, 则使用正整数下标时下标应在 {1, 2, . . . , n} 中取值。如果使用大于 n 的下标，读取时返回缺失值，并不出错。给超出 n 的下标元素赋值，则向量自动变长，中间没有赋值的元素为缺失值。例如

```{r}
x <- c(1,4,6.25) 
x[5]
x
x[5] <- 9
x
```

虽然 R 的语法对下标超界不视作错误，但是这样的做法往往来自不良的程序思路，而且对程序效率有影响，所以实际编程中应避免下标超界。

## 逻辑下标

下标可以是与向量等长的逻辑表达式，一般是关于本向量或者与本向量等长的其它向量的比较结果，如

```{r}
x <- c(1,4,6.25) 
x[x > 3]
```

取出 x 的大于 3 的元素组成的子集。
逻辑下标除了用来对向量取子集，还经常用来对数据框取取子集，也用在向量化的运算中。例如，对如下示性函数

$$
f(x) = \begin{cases}
1, & x \geqslant 0 \\
0, & x \leq 0
\end{cases}
$$

输入向量 x，结果 y 需要也是一个向量，程序可以写成

```{r, warning=FALSE}
f <- function(x){
  y <- numeric(length(x))
  y[x >= 0] <- 1
  y[x < 0] <- 0 # 此语句多余
  
  y
}
```

事实上，向量化的逻辑选择有一个 ifelse() 函数，比如，对上面的示性函数，如果 x 是一个向量，输出 y 向量可以写成 y <- ifelse(x>=0, 1, 0)。

要注意的是，如果逻辑下标中有缺失值，对应结果也是缺失值。所以，在用逻辑下标作子集选择时，一定要考虑到缺失值问题。正确的做法是加上!is.na 前提，如

```{r}
x <- c(1, 4, 6.25, NA) 
x[x > 2]
x[!is.na(x) & x > 2]
```

## which()、which.min()、which.max() 函数

函数 which() 可以用来找到满足条件的下标，如

```{r}
x <- c(3, 4, 3, 5, 7, 5, 9) 
which(x > 5)
seq(along=x)[x > 5]
```

这里 seq(along=x) 会生成由 x 的下标组成的向量。用 which.min()、 which.max 求最小值的下标和最大值的下标，不唯一时只取第一个。如

```{r}
which.min(x)
which.max(x)
```

## 元素名

向量可以为每个元素命名。如

```{r}
ages <- c(" 李明"=30, " 张聪"=25, " 刘颖"=28)
```

或

```{r}
ages <- c(30, 25, 28)
names(ages) <- c(" 李明", " 张聪", " 刘颖")
```

或

```{r}
ages <- setNames(c(30, 25, 28), c(" 李明", " 张聪", " 刘颖"))
```

这时可以用元素名或元素名向量作为向量的下标，如

```{r}
ages[" 张聪"]
ages[c(" 李明", " 刘颖")]
ages[" 张聪"] <- 26
```

这实际上建立了字符串到数值的映射表。

用字符串作为下标时，如果该字符串不在向量的元素名中，读取时返回缺失值结果，赋值时该向量会增加一个元素并以该字符串为元素名。

带有元素名的向量也可以是字符型或其它基本类型，如

```{r}
sex <- c(" 李明"=" 男", " 张聪"=" 男", " 刘颖"=" 女")
```

除了给向量元素命名外，在矩阵和数据框中还可以给行、列命名，这会使得程序的扩展更为容易和安全。

R 允许仅给部分元素命名，这时其它元素名字为空字符串。不同元素的元素名一般应该是不同的，否则在使用元素作为下标时会发生误读，但是 R 语法允许存在重名。

用 unname(x) 返回去掉了元素名的 x 的副本，用 names(x) <- NULL 可以去掉 x 的元素名。

## 用 R 向量下标作映射

R 在使用整数作为向量下标时，允许使用重复下标，这样可以把数组 x 看成一个 1 : n 的整数到 x[1], x[2], . . ., x[n] 的一个映射表, 其中 n 是 x 的长度。比如，某商店有三种礼品，编号为 1,2,3，价格分别为 68, 88 和 168。令

```{r}
price.map <- c(68, 88, 168)
```

设某个收银员在一天内分别售出礼品编号为 3,2,1,1,2,2,3，可以用如下的映射方式获得售出的这些礼品对应的价格：

```{r}
items <- c(3,2,1,1,2,2,3)
y <- price.map[items]; print(y)
```

R 向量可以用字符型向量作下标，字符型下标也允许重复，所以可以把带有元素名的 R 向量看成是元素名到元素值的映射表。比如，设 sex 为 10 个学生的性别（男、女）

```{r}
sex <- c(" 男", " 男", " 女", " 女", " 男", " 女", " 女", " 女", " 女", " 男")
```

希望把每个学生按照性别分别对应到蓝色和红色。首先建立一个 R 向量当作映射

```{r}
sex.color <- c(' 男'='blue', ' 女'='red')
```

用 R 向量 sex.color 当作映射，可以获得每个学生对应的颜色

```{r}
cols <- sex.color[sex]; print(cols)
```

这样的映射结果中带有不必要的元素名，用 unname() 函数可以去掉元素名，
如

```{r}
unname(cols)
```

## 集合运算

可以把向量 x 看成一个集合，但是其中的元素允许有重复。用 unique(x) 可以获得 x 的所有不同值。如

```{r}
unique(c(1, 5, 2, 5))
```

用 a %in% x 判断 a 的每个元素是否属于向量 x，如

```{r}
5 %in% c(1,5,2)
c(5,6) %in% c(1,5,2)
```

与%in 运算符类似，函数 match(x, table) 对向量 x 的每个元素，从向量table 中查找其首次出现位置并返回这些位置。没有匹配到的元素位置返回NA_integer_(整数型缺失值)。如

```{r}
match(5, c(1,5,2))
match(5, c(1,5,2,5))
match(c(2,5), c(1,5,2,5))
match(c(2,5,0), c(1,5,2,5))
```

用 intersect(x,y) 求交集，结果中不含重复元素，如

```{r}
intersect(c(5, 7), c(1, 5, 2, 5))
```

用 union(x,y) 求并集，结果中不含重复元素，如

```{r}
union(c(5, 7), c(1, 5, 2, 5))
```

用 setdiff(x,y) 求差集，即 x 的元素中不属于 y 的元素组成的集合，结果中不含重复元素，如

```{r}
setdiff(c(5, 7), c(1, 5, 2, 5))
```

用 setequal(x,y) 判断两个集合是否相等，不受次序与重复元素的影响，如

```{r}
setequal(c(1,5,2), c(2,5,1))
setequal(c(1,5,2), c(2,5,1,5))
```

## 练习

设文件class.csv内容如下:

name,sex,age,height,weight 

Alice,F,13,56.5,84

Becka,F,13,65.3,98

Gail,F,14,64.3,90

Karen,F,12,56.3,77 

Kathy,F,12,59.8,84.5

Mary,F,15,66.5,112 

Sandy,F,11,51.3,50.5

Sharon,F,15,62.5,112.5 

Tammy,F,14,62.8,102.5

Alfred,M,14,69,112.5 

Duke,M,14,63.5,102.5

Guido,M,15,67,133

James,M,12,57.3,83

Jeffrey,M,13,62.5,84

John,M,12,59,99.5

Philip,M,16,72,150

Robert,M,12,64.8,128

Thomas,M,11,57.5,85

William,M,15,66.5,112

用如下程序可以把上述文件读入为 R 数据框 d.class, 并取出其中的 name 和age 列到变量 name 和 age 中：

```{r, eval=FALSE}
d.class <- read.csv('class.csv', header=TRUE, stringsAsFactors=FALSE) 
name <- d.class[,'name']
age <- d.class[,'age']
```

(1)	求出 age 中第 3, 5, 7 号的值；
(2)	用变量 age, 求出达到 15 岁及以上的那些值；
(3)	用变量 name 和 age, 求出 Mary 与 James 的年龄。
(4)	求 age 中除 Mary 与 James 这两人之外的那些人的年龄值，保存到变量
age1 中。
(5)	假设向量 x 长度为 n, 其元素是 {1, 2, . . . , n} 的一个重排。可以把 x 看
成一个 i 到 x[i] 的映射 (i 在 {1, 2, . . . , n} 中取值)。求向量 y, 保存了上
述映射的逆映射，即：如果 x[i]=j, 则 y[j]=i。


# 矩阵和数组

## R 矩阵

矩阵用 matrix 函数定义，实际存储成一个向量，根据保存的行数和列数对应到矩阵的元素，存储次序为按列存储。定义如

```{r}
A <- matrix(11:16, nrow=3, ncol=2); print(A)
B <- matrix(c(1,-1, 1,1), nrow=2, ncol=2, byrow=TRUE); print(B)
```

matrix() 函数把矩阵元素以一个向量的形式输入，用 nrow 和 ncol 规定行数和列数，向量元素填入矩阵的缺省次序是按列填入，用 byrow=TRUE 选项可以转换成按行填入。

用 nrow() 和 ncol() 函数可以访问矩阵的行数和列数，如

```{r}
nrow(A)
ncol(A)
```

矩阵有一个 dim 属性，内容是两个元素的向量，两个元素分别为矩阵的行数和列数。dim 属性可以用 dim() 函数访问。如

```{r}
attributes(A)
dim(A)
```

函数 t(A) 返回 A 的转置。

## 矩阵子集

用 A[1,] 取出 A 的第一行，变成一个普通向量。用 A[,1] 取出 A 的第一列，变成一个普通向量。用 A[c(1,3),1:2] 取出指定行、列对应的子矩阵。如

```{r}
A
A[1,]
A[,1]
A[c(1,3), 1:2]
```

用 colnames() 函数可以给矩阵每列命名，也可以访问矩阵列名，用rownames() 函数可以给矩阵每行命名，也可以访问矩阵行名。如

```{r}
colnames(A) <- c('X', 'Y') 
rownames(A) <- c('a', 'b', 'c') 
A
```

矩阵可以有一个 dimnames 属性，此属性是两个元素的列表（列表见稍后部分的介绍），两个元素分别为矩阵的行名字符型向量与列名字符型向量。如果仅有
其中之一，缺失的一个取为 NULL。

有了列名、行名后，矩阵下标可以用字符型向量，如

```{r}
A[,'Y']
A['b',]
A[c('a', 'c'), 'Y']
```

注意在对矩阵取子集时，如果取出的子集仅有一行或仅有一列，结果就不再是矩阵而是变成了 R 向量，R 向量既不是行向量也不是列向量。如果想避免这样的规则起作用，需要在方括号下标中加选项 drop=FALSE，如

```{r}
A[,1,drop=FALSE]
```

取出了 A 的第一列，作为列向量取出，所谓列向量实际是列数等于 1 的矩阵。如果用常量作为下标，其结果维数是确定的，不会出问题；如果用表达式作为下标，则表达式选出零个、一个、多个下标，结果维数会有不同，加 drop=FALSE则是安全的做法。

矩阵也可以用逻辑下标取子集，比如

```{r}
A
A[A[,1]>=2,'Y']
```

矩阵本质上是一个向量添加了 dim 属性，实际保存还是保存成一个向量，其中元素的保存次序是按列填入，所以，也可以向对一个向量取子集那样，仅用一个正整数向量的矩阵取子集。如

```{r}
A
A[c(1,3,5)]
```

为了挑选矩阵的任意元素组成的子集而不是子矩阵，可以用一个两列的矩阵作为下标，矩阵的每行的两个元素分别指定一个元素的行号和列号。如

```{r}
ind <- matrix(c(1,1, 2,2, 3,2), ncol=2, byrow=TRUE) 
A
ind
A[ind]
```

用 c(A) 或 A[] 返回矩阵 A 的所有元素。如果要修改矩阵 A 的所有元素，可以对 A[] 赋值。

对矩阵 A，diag(A) 访问 A 的主对角线元素组成的向量。另外，若 x 为正整数值标量，diag(x) 返回 x 阶单位阵；若 x 为长度大于 1 的向量，diag(x)返回以 x 的元素为主对角线元素的对角矩阵。

## cbind() 和 rbind() 函数

若 x 是向量，cbind(x) 把 x 变成列向量，即列数为 1 的矩阵，rbind(x) 把x 变成行向量。

若 x1, x2, x3 是等长的向量，cbind(x1, x2, x3) 把它们看成列向量并在一起组成一个矩阵。cbind() 的自变量可以同时包含向量与矩阵，向量的长度必须与矩阵行数相等。如

```{r}
cbind(c(1,2), c(3,4), c(5,6))
cbind(A, c(1,-1,10))
```

cbind() 的自变量中也允许有标量，这时此标量被重复使用。如

```{r}
cbind(1, c(1,-1,10))
```

rbind() 用法类似，可以等长的向量看成行向量上下摞在一起，可以是矩阵与长度等于矩阵列数的向量上下摞在一起，向量长度为 1 也可以。

## 矩阵运算

### 四则运算

矩阵可以与标量作四则运算，结果为每个元素进行相应运算，如

```{r}
A
C1 <- A + 2; C1
C2 <- A / 2; C2
```

当运算为矩阵乘以一个标量时，就是线性代数中的矩阵的数乘运算。
两个同形状的矩阵进行加、减运算，即对应元素相加、相减，用 A + B，A - B表示，如

```{r}
C1 + C2
C1 - C2
```

这就是线性代数中矩阵的加、减运算。
对两个同形状的矩阵，用 * 表示两个矩阵对应元素相乘 (注意这不是线性代数中的矩阵乘法)，用/表示两个矩阵对应元素相除。如

```{r}
C1 * C2
C1 / C2
```

### 矩阵乘法
用\%\*\% 表示矩阵乘法而不是用 \* 表示，注意矩阵乘法要求左边的矩阵的列数等于右边的矩阵的行数。如

```{r}
A
B
C3 <- A %*% B; C3
```

### 向量与矩阵相乘

矩阵与向量进行乘法运算时，向量按需要解释成列向量或行向量。当向量左乘矩阵时，看成行向量；当向量右乘矩阵时，看成列向量。如

```{r}
B
c(1,1) %*% B
B %*% c(1,1)
c(1,1) %*% B %*% c(1,1)
```

注意矩阵乘法总是给出矩阵结果，即使此矩阵已经退化为行向量、列向量甚至
于退化为标量也是一样。如果需要，可以用 c() 函数把一个矩阵转换成按列拉直的向量。

### 内积

设 x, y 是两个向量，计算向量内积，可以用 sum(x*y) 表示。

设 A, B 是两个矩阵，AT B 是广义的内积，也称为叉积 (crossprod)，结果是一个矩阵，元素为 A 的每列与 B 的每列计算内积的结果。AT B 在 R 中可以表示为 crossprod(A, B), AT A 可以表示为 crossprod(A)。要注意的是，crossprod() 的结果总是矩阵，所以计算两个向量的内积用 sum(x,y) 而不用crossprod(x,y)。

### 外积

R 向量支持外积运算，记为%o%, 结果为矩阵。x %o% y 的第 i 行第 j 列元素等于 x[i] 乘以 y[j]。如

```{r}
c(1,2,3) %o% c(1, -1)
```

这种运算还可以推广到 x 的每一元素与 y 的每一元素进行其它的某种运算，而不限于乘积运算，可以用 outer(x,y,f) 完成，其中 f 是某种运算，或者接受两个自变量的函数。

## 逆矩阵与线性方程组求解
用 solve(A) 求 A 的逆矩阵，如

```{r}
solve(B)
```

用 solve(A,b) 求解线性方程组 Ax = b 中的 x, 如

```{r}
solve(B, c(1,2))
```

求解了线性方程组

$$
\begin{bmatrix}
1 & -1 \\
1 & 1
\end{bmatrix} x = 
\begin{bmatrix}
1 \\
2
\end{bmatrix}
$$

## apply() 函数

apply(A, 2, FUN) 把矩阵 A 的每一列分别输入到函数 FUN 中，得到对应于每一列的结果，如

```{r}
D <- matrix(c(6,2,3,5,4,1), nrow=3, ncol=2); D
apply(D, 2, sum)
```

apply(A, 1, FUN) 把矩阵 A 的每一行分别输入到函数 FUN 中，得到与每一行对应的结果，如

```{r}
apply(D, 1, mean)
```

如果函数 FUN 返回多个结果，则 apply(A, 2, FUN) 结果为矩阵，矩阵的每一列是输入矩阵相应列输入到 FUN 的结果，结果列数等于 A 的列数。如

```{r}
apply(D, 2, range)
```

如果函数 FUN 返回多个结果，为了对每行计算 FUN 的结果，结果存入一个与输入的矩阵行数相同的矩阵，应该用 t(apply(A, 1, FUN)) 的形式，如

```{r}
t(apply(D, 1, range))
```

## 多维数组

矩阵是多维数组 (array) 的特例。矩阵是 xij , i = 1, 2, . . . , n, j = 1, 2, . . . , m这样的两下标数据的存贮格式，三维数组是 xijk, i = 1, 2, . . . , n, j = 1, 2, . . . , m, k = 1, 2, . . . , p 这样的三下标数据的存贮格式，s 维数组则是有 s个下标的数据的存贮格式。实际上，给一个向量添加一个 dim 属性就可以把它变成多维数组。

多维数组的一般定义语法为

数组名 <- array(数组元素, dim=c(第一下标个数, 第二下标个数, ..., 第s下标个数))

其中数组元素的填入次序是第一下标变化最快，第二下标次之，最后一个下标是变化最慢的。这种次序称为 FORTRAN 次序。

下面是一个三维数组定义例子。

```{r}
ara <- array(1:24, dim=c(2,3,4)); ara
```

这样的数组保存了 xijk, i = 1, 2, j = 1, 2, 3, k = 1, 2, 3, 4。三维数组 ara 可以看成是 4 个 2 × 3 矩阵。取出其中一个如 $ara[,,2]$(取出第二个矩阵)

```{r}
ara[,,2]
```

多维数组可以利用下标进行一般的子集操作，比如 ara[,2, 2:3] 是 $x_{ijk}, i = 1, 2, j = 2, k = 2, 3$ 的值，结果是一个 2 × 2 矩阵:

```{r}
ara[,2,2:3]
```

多维数组在取子集时如果某一维下标是标量，则结果维数会减少，可以在方括号内用 drop=FALSE 选项避免这样的规则发生作用。

类似于矩阵，多维数组可以用一个矩阵作为下标，如果是三维数组，矩阵就需要有 3 列，四维数组需要用 4 列矩阵。下标矩阵的每行对应于一个数组元素。

# 数据框

## 数据框

统计分析中最常见的原始数据形式是类似于数据库表或 Excel 数据表的形式。这样形式的数据在 R 中叫做数据框 (data.frame)。数据框类似于一个矩阵，有n 行、p 列，但各列允许有不同类型：数值型向量、因子、字符型向量、日期时间向量。同一列的数据类型相同。在 R 中数据框是一个特殊的列表，其每个列
表元素都是一个长度相同的向量。事实上，数据框还允许一个元素是一个矩阵，但这样会使得某些读入数据框的函数发生错误。

函数 data.frame() 可以生成数据框，如

```{r}
d <- data.frame(
  name=c(" 李明", " 张聪", " 王建"), 
  age=c(30, 35, 28),
  height=c(180, 162, 175), 
  stringsAsFactors=FALSE)
print(d)
```

data.frame() 函数会将字符型列转换成因子，加选项 stringsAsFactors=FALSE可以避免这样的转换。

数据框每列叫做一个变量，每列都有名字，称为列名或变量名，可以用 names()函数和 colnames() 函数访问。如

```{r}
names(d)
colnames(d)
```

给 names(d) 或 colnames(d) 赋值可以修改列名。

用 as.data.frame(x) 可以把 x 转换成数据框。如果 x 是一个向量，转换结果是以 x 为唯一一列的数据框。如果 x 是一个列表并且列表元素都是长度相同的向量，转换结果中每个列表变成数据框的一列。如果 x 是一个矩阵，转换结果把矩阵的每列变成数据框的一列。

数据框是一个随着 R 语言前身 S 语言继承下来的概念，现在已经有一些不足之处，tibble 包提供了 tibble 类，这是数据框的一个改进版本。

## 数据框内容访问

数据框可以用矩阵格式访问，如

```{r}
d[2,3]
d[[2]]
```

访问第二列，结果为向量。

```{r}
d[,2]
```

也访问第二列，但是这种作法与 tibble 不兼容，所以应避免使用。按列名访问列可用如

```{r}
d[["age"]]
d[,"age"]
d$age
```

其中第二种做法与 tibble 不兼容，应避免使用。
因为数据框的一行不一定是相同数据类型，所以数据框的一行作为子集，结果还是数据框，而不是向量。如

```{r}
x <- d[2,]; x
is.data.frame(x)
```

可以同时取行子集和列子集，如

```{r}
d[1:2, 'age']
d[1:2, c('age', 'height')]
d[d[,'age']>=30,]
```

与矩阵类似地是，用如 d[,'age'], d[,2] 这样的方法取出的数据框的单个列是向量而不再是数据框。但是，如果取出两列或者两列以上，结果则是数据框。如果取列子集时不能预先知道取出的列个数，则子集结果有可能是向量也有可能是数据框，容易造成后续程序错误。对一般的数据框，可以在取子集的方括号内加上 drop=FALSE 选项，确保取列子集的结果总是数据框。数据框的改进类型 tibble 在取出列子集时保持为 tibble 格式。

对数据框变量名按照字符串与集合进行操作可以实现复杂的列子集筛选。
数据框每一行可以有行名，这在原始的 S 语言和传统的 R 语言中是重要的技术，但是在改进类型 tibble 中则取消了行名，需要用列名实现功能一般改用left_join() 函数实现。

比如，每一行定义行名为身份证号，则可以唯一识别各行。下面的例子以姓名作为行名:

```{r}
rownames(d) <- d$name 
d$name <- NULL
d
```

用数据框的行名可以建立一个值到多个值的对应表。比如，有如下的数据框：

```{r}
dm <- data.frame(
  ' 年级'=1:6,
  ' 出游'=c(0, 2, 2, 2, 2, 1), 
  ' 疫苗'=c(T, F, F, F, T, F)
 )
```

其中 “出游” 是每个年级安排的出游次数，“疫苗” 是该年级有全体无计划免疫注射。把年级变成行名，可以建立年级到出游次数与疫苗注射的对应表：

```{r}
rownames(dm) <- dm[[' 年级']] 
dm[[' 年级']] <- NULL
```

这样，假设某个社区的小学中抽取的 4 个班的年级为 c(2,1,1,3)，其对应的出游和疫苗注射信息可查询如下：

```{r}
x <- c(2,1,1,3) 
dm[as.character(x),]
```

结果中包含了不必要也不太合适的行名，可以去掉，以上程序改成：

```{r}
x <- c(2,1,1,3)
xx <- dm[as.character(x),] 
rownames(xx) <- NULL
xx
```

如果要从多个值建立映射，比如，从省名与县名映射到经度、纬度，可以预先用
paste() 函数把省名与县名合并在一起，中间以适当字符（如 ‘-“) 分隔，以这样的合并字符串为行名。

对于代替数据框的 tibble 类型，如果要实现行名的功能，可以将行名作为单独的一列，然后用 dplyr 包的 inner_join()、left_join()、full_join() 等函数横向合并数据集。参见27.15。

## 数据框与矩阵的区别

数据框不能作为矩阵参加矩阵运算。需要时，可以用 as.matrix() 函数转换数据框或数据框的子集为矩阵。如

```{r}
d2 <- as.matrix(d[,c("age", "height")]) 
d3 <- crossprod(d2); d3
```

这里 crossprod(A) 表示 $A^TA$。

## gl() 函数

可以用数据框保存试验结果，对有多个因素的试验，往往需要生成多个因素完
全搭配并重复的表格。函数 gl() 可以生成这样的重复模式。比如，下面的例子：

```{r}
d4 <- data.frame(
  group=gl(3, 10, length=30), 
  subgroup=gl(5,2,length=30), 
  obs=gl(2,1,length=30))
print(d4)
```

结果的数据框 d 有三个变量: group 是大组，共分 3 个大组，每组 10 个观测；subgroup 是子组，在每个大组内分为 5 个子组，每个子组 2 个观测。共有3 × 5 × 2 = 30 个观测（行）。

gl() 第一个参数是因子水平个数，第二个参数是同一因子水平连续重复次数，第三个参数是总共需要的元素个数，所有水平都出现后则重复整个模式直到长度满足要求。

## tibble 类型

tibble 类型是一种改进的数据框。readr 包的 read_csv() 函数是 read.csv()函数的一个改进版本，它将 CSV 文件读入为 tibble 类型，如文件class.csv的读入:


```{r}
library(tibble)
library(readr)
t.class <- read_csv("class.csv")
t.class
```

tibble 类型的类属依次为 tbl_df, tbl, data.frame：

```{r}
class(t.class)
```

用 as_tibble() 可以将一个数据框转换为 tibble, dplyr 包提供了 filter()、 select()、arrange()、mutate() 等函数用来对 tibble 选取行子集、列子集，排序、修改或定义新变量，等等。见27。

可以用 tibble() 函数生成小的 tibble，如

```{r}
t.bp <- tibble(
  `序号`=c(1,5,6,9,10,15),
  `收缩压`=c(145, 110, " 未测", 150, " 拒绝", 115))
t.bp
```

用 tribble 可以按类似于 CSV 格式输入一个tibble, 如


注意 tribble() 中数据每行末尾也需要有逗号，最后一行末尾没有逗号。这比较适用于在程序中输入小的数据集。

tibble 与数据框的一大区别是在显示时不自动显示所有内容，这样可以避免显示很大的数据框将命令行的所有显示都充满。可以在 print() 用 n= 和 width=选项指定要显示的行数和列数。

另外，用单重的方括号取列子集时，即使仅取一列，从 tibble 取出的一列结果仍是 tibble 而不是向量，这时应使用双方括号格式或 $ 格式。因为这个原因有些原来的程序输入 tibble 会出错，这时可以用 as.data.frame() 转换成数据框。如：

```{r, warning=FALSE}
t.bp[,"收缩压"]
t.bp[["收缩压"]]
```

tibble 在定义时不需要列名为合法变量名，但是作为变量名使用时需要用反单撇号包裹。tibble 不使用行名，需要行名时，将其保存为 tibble 的一列。原来用行名完成的功能，可以改用 dplyr 包的 left_join() 等函数，这些函数进行数据框的横向连接。

## 练习

假设class.csv已经读入为 R 数据框 d.class, 其中的 sex 列已经自动转换为因子。

(1)	显示 d.class 中年龄至少为 15 的行子集；
(2)	显示女生且年龄至少为 15 的学生姓名和年龄；
(3)	取出数据框中的 age 变量赋给变量 x。

# 列表类型

## 列表

R 中列表 (list) 类型来保存不同类型的数据。一个主要目的是提供 R 分析结果输出包装：输出一个变量，这个变量包括回归系数、预测值、残差、检验结果等等一系列不能放到规则形状数据结构中的内容。实际上，数据框也是列表的一种，但是数据框要求各列等长，而列表不要求。

列表可以有多个元素，但是与向量不同的是，列表的不同元素的类型可以不同，比如，一个元素是数值型向量，一个元素是字符串，一个元素是标量，一个元素是另一个列表。

定义列表用函数 list(), 如

```{r}
rec <- list(name=" 李明", age=30,
            scores=c(85, 76, 90))
rec
```

用 typeof() 函数判断一个列表，返回结果为 list。可以用 is.list() 函数判断某个对象是否列表类型。

## 列表元素访问

列表的一个元素也可以称为列表的一个 “变量”，单个列表元素必须用两重方括号格式访问，如

```{r}
rec[[3]]
rec[[3]][2]
rec[["age"]]
```

如果使用单重方括号对列表取子集，结果还是列表而不是列表元素，如

```{r}
rec[3]
```

列表的单个元素也可以用 $ 格式访问，如

```{r}
rec$age
```

列表一般都应该有元素名，元素名可以看成是变量名，列表中的每个元素看成一个变量。用 names() 函数查看和修改元素名。如

```{r}
names(rec)
names(rec)[names(rec)=='scores'] <- ' 三科分数' 
names(rec)
rec[[" 三科分数"]]
```

可以修改列表元素内容。如

```{r}
rec[[" 三科分数"]][2] <- 0 
print(rec)
```

直接给列表不存在的元素名定义元素值就添加了新元素，而且不同于使用向量，对于列表而言这是很正常的做法，比如


```{r}
rec[[' 身高']] <- 178 
print(rec)
```

把某个列表元素赋值为 NULL 就删掉这个元素。如

```{r}
rec[['age']] <- NULL 
print(rec)
```

在 list() 函数中允许定义元素为 NULL，这样的元素是存在的，如：

```{r}
li <- list(a=120, b='F', c=NULL); li
```

但是，要把已经存在的元素修改为 NULL 值而不是删除此元素，或者给列表增加一个取值为 NULL 的元素，这时需要用单重的方括号取子集，这样的子集会保持其列表类型，给这样的子列表赋值为 list(NULL)，如：

```{r}
li['b'] <- list(NULL) 
li['d'] <- list(NULL) 
li
```

## 列表类型转换

用 as.list() 把一个其它类型的对象转换成列表；用 unlist() 函数把列表转换成基本向量。如

```{r}
li1 <- as.list(1:3) 
li1
li2 <- list(x=1, y=c(2,3)) 
unlist(li2)
```

## 返回列表的函数示例–strsplit()

strsplit() 输入一个字符型向量并指定一个分隔符，返回一个项数与字符型向量元素个数相同的列表，列表每项对应于字符型向量中一个元素的拆分结果。如

```{r}
x <- c('10, 8, 7', '5, 2, 2', '3, 7, 8', '8, 8, 9') 
res <- strsplit(x, ','); res
```

为了把拆分结果进一步转换成一个数值型矩阵，可以使用 sapply() 函数如下：

```{r}
t(sapply(res, as.numeric))
```

sapply() 函数是 apply 类函数之一，稍后再详细进行讲解。

# 工作空间

R 把在命令行定义的变量都保存到工作空间中，在退出 R 时可以选择是否保存工作空间。这也是 R 与其他如 C、Java 这样的语言的区别之一。

用 ls() 命令可以查看工作空间中的内容。

随着多次在命令行使用 R，工作空间的变量越来越多，使得重名的可能性越来越大，而且工作空间中变量太多也让我们不容易查看其内容。在命令行定义的
变量称为 “全局变量”，在编程实际中，全局变量是需要慎用的。

可以用 rm() 函数删除工作空间中的变量，格式如

```{r, eval=FALSE}
rm(d, h, name, rec, sex, x)
```

要避免工作空间杂乱，最好的办法还是所有的运算都写到自定义函数中。自定义函数中定义的变量都是临时的，不会保存到工作空间中。这样，仅需要时才把变量值在命令行定义，这样的变量一般是读入的数据或自定义的函数（自定义函数也保存在工作空间中）。

可以定义如下的 sandbox() 函数：

```{r}
sandbox <- function(){
  cat(' 沙盘：接连的空行回车可以退出。\n') 
  browser()
}
```

运行 sandbox() 函数，将出现如下的 browser 命令行：

沙盘：接连的空行回车可以退出。

Called from: sandbox()

Browse[1]>

提示符变成了 “Browser[n]”，其中 n 代表层次序号。在这样的 browser 命令行中随意定义变量，定义的变量不会保存到工作空间中。用 “Q” 命令可以退出这个沙盘环境，接连回车也可以退出。


# 数据类型的性质

## 存储模式与基本类型

R 的变量可以存储多种不同的数据类型，可以用 typeof() 函数来返回一个变量或表达式的类型。比如

```{r}
typeof(1:3)
typeof(c(1,2,3))
typeof(c(TRUE, NA, FALSE))
typeof('Abc')
typeof(factor(c('F', 'M', 'M', 'F')))
```

注意因子的结果是 integer 而不是因子。函数 mode() 和 storage.mode()以及 typeof() 类似，但返回结果有差别。这三个函数都是与存储类型有关，不依赖于变量和表达式的实际作用。

R 中数据的最基本的类型包括 logical, integer, double, character, complex, raw, 其它数据类型都是由基本类型组合或转变得到的。character 类型就是字符串类型，raw 类型是直接使用其二进制内容的类型。为了判断某个向量 x 保存的基本类型，可以用 is.xxx() 类函数，如 is.integer(x), is.double(x), is.numeric(x), is.logical(x), is.character(x), is.complex(x), is.raw(x)。其中 is.numeric(x) 对 integer 和 double 内容都返回真值。

在 R 语言中数值一般看作 double, 如果需要明确表明某些数值是整数，可以在数值后面附加字母 L，如

```{r}
is.integer(c(1, -3))
is.integer(c(1L, -3L))
```

整数型的缺失值是 NA，而 double 型的特殊值除了 NA 外，还包括 Inf, -Inf和 NaN，其中 NaN 也算是缺失值, Inf 和-Inf 不算是缺失值。如:

```{r}
c(-1, 0, 1)/0
is.na(c(-1, 0, 1)/0)
```

对 double 类型，可以用 is.finite() 判断是否有限值，NA、Inf, -Inf 和NaN 都不是有限值；用 is.infinite() 判断是否 Inf 或-Inf；is.na() 判断是否 NA 或 NaN；is.nan() 判断是否 NaN。

严格说来，NA 表示逻辑型缺失值，但是当作其它类型缺失值时一般能自动识别。NA_integer_ 是整数型缺失值，NA_real_ 是 double 型缺失值， NA_character_ 是字符型缺失值。

在 R 的向量类型中，integer 类型、double 类型、logical 类型、character 类型、还有 complex 类型和 raw 类型称为原子类型 (atomic types)，原子类型的向量中元素都是同一基本类型的。比如，double 型向量的元素都是 double 或者缺失值。除了原子类型的向量，在 R 语言的定义中，向量还包括后面要讲到的列表（list），列表的元素不需要属于相同的基本类型，而且列表的元素可以不是单一基本类型元素。用 typeof() 函数可以返回向量的类型，列表返回结果为"list":

```{r}
typeof(list("a", 1L, 1.5))
```

原子类型的各个元素除了基本类型相同，还不包含任何嵌套结构，如：

```{r}
c(1, c(2,3, c(4,5)))
```

## 类属

R 具有一定的面向对象语言特征，其数据类型有一个 class 属性，函数class() 可以返回变量类型的类属，比如

```{r}
typeof(factor(c('F', 'M', 'M', 'F')))
mode(factor(c('F', 'M', 'M', 'F')))
storage.mode(factor(c('F', 'M', 'M', 'F')))
class(factor(c('F', 'M', 'M', 'F')))
class(as.numeric(factor(c('F', 'M', 'M', 'F'))))
```

R 有一个特殊的 NULL 类型，这个类型只有唯一的一个 NULL 值，表示不存在。要把 NULL 与 NA 区分开来，NA 是有类型的（integer、double、logical、 character 等), NA 表示存在但是未知。用 is.null() 函数判断某个变量是否取 NULL。

## 类型转换

可以用 as.xxx() 类的函数在不同类型之间进行强制转换。如

```{r}
as.numeric(c(FALSE, TRUE))
as.character(sqrt(1:4))
```

类型转换也可能是隐含的，比如，四则运算中数值会被统一转换为 double 类型，逻辑运算中运算元素会被统一转换为 logical 类型。逻辑值转换成数值时， TRUE 转换成 1，FALSE 转换成 0。

在用 c() 函数合并若干元素时，如果元素基本类型不同，将统一转换成最复杂的一个，复杂程度从简单到复杂依次为：logical<integer<double<character。如

```{r}
c(FALSE, 1L, 2.5, "3.6")
```

不同类型参与要求类型相同的运算时，也会统一转换为最复杂的类型，如：

```{r}
TRUE + 10
paste("abc", 1)
```

## 属性

除了 NULL 以外，R 的变量都可以看成是对象，都可以有属性。在 R 语言中，属性是把变量看成对象后，除了其存储内容（如元素）之外的其它附加信息，如
维数、类属等。对象 x 的所有属性可以用 attributes() 读取，如

```{r}
x <- table(c(1,2,1,3,2,1)); print(x)
attributes(x)
```

table() 函数用了输出其自变量中每个不同值的出现次数，称为频数。从上例可以看出，table() 函数的结果有三个属性，前两个是 dim 和 dimnames, 这是数组 (array) 具有的属性；另一个是 class 属性，值为"table"。因为 x 是数组，可以访问如

```{r}
x[1]
x["3"]
```

也可以用 attributes() 函数修改属性，如

```{r}
attributes(x) <- NULL 
x
```

如上修改后 x 不再是数组，也不是 table。

class 属性是特殊的。如果一个对象具有class 属性，某些所谓“通用函数(generic functions)” 会针对这样的对象进行专门的操作，比如，print() 函数在显示向量和回归结果时采用完全不同的格式。这在其它程序设计语言中称为 “重载”(overloading)。

可以用 attr(对象, " 属性名") 读取和修改单个属性。向量的元素名是names 属性，例如

```{r}
ages <- c(" 李明"=30, " 张聪"=25, " 刘颖"=28)
names(ages)
attr(ages, "names")
attr(ages, "names") <- NULL 
ages
```

还可以用 unname() 函数返回一个去掉了 names 属性的副本。

## str() 函数

用 print() 函数可以显示对象内容。如果内容很多，显示行数可能也很多。用str() 函数可以显示对象的类型和主要结构及典型内容。例如

```{r}
s <- 101:200
attr(s,'author') <- ' 李小明' 
attr(s,'date') <- '2016-09-12' 
str(s)
```

## 关于赋值

要注意的是，在 R 中赋值本质上是把一个存储的对象与一个变量名联系在一起(binding)，多个变量名可以指向同一个对象。对于基本的数据类型如数值型向量，两个指向相同对象的变量当一个变量被修改时自动制作副本，如

```{r}
x <- 1:5
y <- x
y[3] <- 0
x
```

这里如果 y 没有与其它变量指向同一对象，则修改时直接修改该对象而不制作副本。

但是对于有些比较复杂的类型，两个指向同一对象的变量是同步修改的。这样
的类型的典型代表是闭包 (closure)，它带有一个环境，环境的内容是不自动制作副本的。

# 日期时间

## R 日期和日期时间类型

R 日期可以保存为 Date 类型，一般用整数保存，数值为从 1970-1-1 经过的天数。

R 中用一种叫做 POSIXct 和 POSIXlt 的特殊数据类型保存日期和时间，可以仅包含日期部分，也可以同时有日期和时间。技术上，POSIXct 把日期时间保存为从 1970 年 1 月 1 日零时到该日期时间的时间间隔秒数，所以数据框中需要保存日期时用 POSIXct 比较合适，需要显示时再转换成字符串形式；POSIXlt 把日期时间保存为一个包含年、月、日、星期、时、分、秒等成分的列表，所以求这些成分可以从 POSIXlt 格式日期的列表变量中获得。日期时间会涉及到所在时区、夏时制等问题，比较复杂。

基础的 R 用 as.Date()、as.POSIXct() 等函数生成日期型和日期时间型，R扩展包 lubridate 提供了多个方便函数，可以更容易地生成、转换、管理日期型和日期时间型数据。

```{r}
library(lubridate)
```

## 从字符串生成日期数据

函数 lubridate::today() 返回当前日期：

```{r}
today()
```

函数 lubridate::now() 返回当前日期时间：

```{r}
now()
```

结果显示中出现的 CST 是时区，这里使用了操作系统提供的当前时区。CST 不是一个含义清晰的时区，在不同国家对应不同的时区，在中国代表中国标准时间（北京时间）。

用 lubridate::ymd(), lubridate::mdy(), lubridate::dmy() 将字符型向量转换为日期型向量，如：

```{r}
ymd(c("1998-3-10", "2018-01-17", "18-1-17"))
mdy(c("3-10-1998", "01-17-2018"))
dmy(c("10-3-1998", "17-01-2018"))
```

在年号只有两位数字时，默认对应到 1969-2068 范围。
lubridate::make_date(year, month, day) 可以从三个数值构成日期向量。如

```{r}
make_date(1998, 3, 10)
```

lubridate 包的 ymd、mdy、dmy 等函数添加 hms、hm、h 等后缀，可以用于将字符串转换成日期时间。如

```{r}
ymd_hms("1998-03-16 13:15:45")
```

结果显示中 UTC 是时区，UTC 是协调世界时 (Universal Time Coordinated)英文缩写，是由国际无线电咨询委员会规定和推荐, 并由国际时间局 (BIH) 负责保持的以秒为基础的时间标度。UTC 相当于本初子午线 (即经度 0 度) 上的平均太阳时，过去曾用格林威治平均时 (GMT) 来表示. 北京时间比 UTC 时间早 8 小时，以 1999 年 1 月 1 日 0000UTC 为例，UTC 时间是零点，北京时间为 1999 年 1 月 1 日早上 8 点整。

在 Date()、as.DateTime()、ymd() 等函数中，可以用 tz= 指定时区，比如北京时间可指定为 tz="Etc/GMT+8" 或 tz="Asia/Shanghai"。

lubridate::make_datetime(year, month, day, hour, min, sec) 可以从最多六个数值组成日期时间，其中时分秒缺省值都是 0。如

```{r}
make_datetime(1998, 3, 16, 13, 15, 45.2)
```

用 lubridate::as_date() 可以将日期时间型转换为日期型，如

```{r}
as_datetime(as.Date("1998-03-16"))
```

## 日期显示格式

用 as.character() 函数把日期型数据转换为字符型, 如

```{r}
x <- as.POSIXct(c('1998-03-16', '2015-11-22'))
as.character(x)
```

在 as.character() 中可以用 format 选项指定显示格式，如

```{r}
as.character(x, format='%m/%d/%Y')
```

格式中 “%Y” 代表四位的公元年号，“%m” 代表两位的月份数字，“%d” 代表两位的月内日期号。

"15Mar98" 这样的日期在英文环境中比较常见，但是在 R 中的处理比较复杂。在下面的例子中，R 日期被转换成了类似"Mar98" 这样的格式，在 format 选项中用了 “%b” 代表三英文字母月份缩写，但是因为月份缩写依赖于操作系统默认语言环境，需要用 Sys.setlocale() 函数设置语言环境为"C"。示例程序
如下

```{r}
x <- as.POSIXct(c('1998-03-16', '2015-11-22'))
old.lctime <- Sys.getlocale('LC_TIME')
Sys.setlocale('LC_TIME', 'C')
as.character(x, format='%b%y')
Sys.setlocale('LC_TIME', old.lctime)
```

format 选项中的 “%y” 表示两位数的年份，应尽量避免使用两位数年份以避免混淆。
包含时间的转换如

```{r}
x <- as.POSIXct('1998-03-16 13:15:45') 
as.character(x)
as.character(x, format='%H:%M:%S')
```

这里 “%H” 代表小时（按 24 小时制），“%M” 代表两位的分钟数字，“%S” 代表两位的秒数。

## 访问日期时间的组成值

lubridate 包的如下函数可以取出日期型或日期时间型数据中的组成部分：

-	year() 取出年
-	month() 取出月份数值
-	mday() 取出日数值
-	yday() 取出日期在一年中的序号，元旦为 1
-	wday() 取出日期在一个星期内的序号，但是一个星期从星期天开始，星期天为 1, 星期一为 2，星期六为 7。
-	hour() 取出小时
-	minute() 取出分钟
-	second() 取出秒

比如, 2018-1-17 是星期三，则

```{r}
month(as.POSIXct("2018-1-17 13:15:40"))
mday(as.POSIXct("2018-1-17 13:15:40"))
wday(as.POSIXct("2018-1-17 13:15:40"))
```

lubridate 的这些成分函数还允许被赋值，结果就修改了相应元素的值，如

```{r}
x <- as.POSIXct("2018-1-17 13:15:40") 
year(x) <- 2000
month(x) <- 1
mday(x) <- 1
x
```

update() 可以对一个日期或一个日期型向量统一修改其组成部分的值，如

```{r}
x <- as.POSIXct("2018-1-17 13:15:40") 
y <- update(x, year=2000)
y
```

update() 函数中可以用 year, month, mday, hour, minute, second 等参数修改日期的组成部分。

## 日期舍入计算

lubridate 包提供了 floor_date(), round_date(), ceiling_date() 等函数，对日期可以用 unit= 指定一个时间单位进行舍入。时间单位为字符串，如seconds, 5 seconds, minutes, 2 minutes, hours, days, weeks, months, years 等。

比如，以 10 minutes 为单位，floor_date() 将时间向前归一化到 10分钟的整数倍，ceiling_date() 将时间向后归一化到 10 分钟的整数倍， round_date() 将时间归一化到最近的 10 分钟的整数倍，时间恰好是 5 分钟倍数时按照类似四舍五入的原则向上取整。例如

```{r}
x <- ymd_hms("2018-01-11 08:32:44") 
floor_date(x, unit="10 minutes")
ceiling_date(x, unit="10 minutes")
round_date(x, unit="10 minutes")
```

如果单位是星期，会涉及到一个星期周期的开始是星期日还是星期一的问题。用参数 week_start=7 指定开始是星期日，week_start=1 指定开始是星期一。

## 日期计算

在 lubridate 的支持下日期可以相减，可以进行加法、除法。lubridate 包提供了如下的三种与时间长短有关的数据类型：

-	时间长度 (duration)，按整秒计算
-	时间周期 (period)，如日、周
-	时间区间 (interval)，包括一个开始时间和一个结束时间

### 时间长度

R 的 POSIXct 日期时间之间可以相减，如

```{r}
d1 <- ymd_hms("2000-01-01 0:0:0") 
d2 <- ymd_hms("2000-01-02 12:0:5") 
di <- d2 - d1; di
```

结果显示与日期之间差别大小有关系，结果是类型是 difftime。 lubridate 包提供了 duration 类型，处理更方便：

```{r}
as.duration(di)
```

lubridate 的 dseconds(), dminutes(), dhours(), ddays(), dweeks(), dyears() 函数可以直接生成时间长度类型的数据，如

```{r}
dhours(1)
```

lubridate 的时间长度类型总是以秒作为单位，可以在时间长度之间相加，也可以对时间长度乘以无量纲数，如

```{r}
dhours(1) + dseconds(5)
dhours(1)*10
```

可以给一个日期加或者减去一个时间长度，结果严格按推移的秒数计算，如

```{r}
d2 <- ymd_hms("2000-01-02 12:0:5") 
d2 - dhours(5)
d2 + ddays(10)
```

时间的前后推移在涉及到时区和夏时制时有可能出现未预料到的情况。

用 unclass() 函数将时间长度数据的类型转换为普通数值，如：

```{r}
unclass(dhours(1))
```

### 时间周期

时间长度的固定单位是秒，但是像月、年这样的单位，因为可能有不同的天数，所以日历中的时间单位往往没有固定的时长。

lubridate 包的 seconds(), minutes(), hours(), days()，weeks(), years()
函数可以生成以日历中正常的周期为单位的时间长度，不需要与秒数相联系，可以用于时间的前后推移。这些时间周期的结果可以相加、乘以无量纲整数：

```{r}
years(2) + 10*days(1)
```

lubridate 的月度周期因为与已有函数名冲突，所以没有提供，需要使用lubridate::period(num, units="month") 的格式，其中 num 是几个月的数值。

为了按照日历进行日期的前后平移，而不是按照秒数进行日期的前后平移，应该使用这些时间周期。例如，因为 2016 年是闰年，按秒数给 2016-01-01 加一年，得到的并不是 2017-01-01：

```{r}
ymd("2016-01-01") + dyears(1)
```

使用时间周期函数则得到预期结果：

```{r}
ymd("2016-01-01") + years(1)
```

### 时间区间

lubridate 提供了%--% 运算符构造一个时间期间。时间区间可以求交集、并集等。
构造如：

```{r}
d1 <- ymd_hms("2000-01-01 0:0:0") 
d2 <- ymd_hms("2000-01-02 12:0:5") 
din <- (d1 %--% d2); din
```

对一个时间区间可以用除法计算其时间长度，如

```{r}
din / ddays(1)
din / dseconds(1)
```

生成时间区间，也可以用 lubridate::interval(start, end) 函数，如

```{r}
interval(ymd_hms("2000-01-01 0:0:0"), ymd_hms("2000-01-02 12:0:5"))
```

可以指定时间长度和开始日期生成时间区间，如

```{r}
d1 <- ymd("2018-01-15")
din <- as.interval(dweeks(1), start=d1); din
```

注意这个时间区间表面上涉及到 8 个日期，但是实际长度还是只有 7 天，因为每一天的具体时间都是按零时计算，所以区间末尾的那一天实际不含在内。

用 lubridate::int_start() 和 lubridate::int_end() 函数访问时间区间的端点，如：

```{r}
int_start(din)
int_end(din)
```

可以用 as.duration() 将一个时间区间转换成时间长度，用 as.period()将一个时间区间转换为可变时长的时间周期个数。

用 lubridate::int_shift() 平移一个时间区间，如

```{r}
din2 <- int_shift(din, by=ddays(3)); din2
```

用 lubridate::int_overlaps() 判断两个时间区间是否有共同部分，如

```{r}
int_overlaps(din, din2)
```

时间区间允许开始时间比结束时间晚，用 lubridate::int_standardize()可以将时间区间标准化成开始时间小于等于结束时间。lubridate() 现在没有提供求交集的功能，一个自定义求交集的函数如下：

```{r}
int_intersect <- function(int1, int2){
  n <- length(int1)
  int1 <- lubridate::int_standardize(int1) 
  int2 <- lubridate::int_standardize(int2) 
  sele <- lubridate::int_overlaps(int1, int2) 
  inter <- rep(lubridate::interval(NA, NA), n)
  if(any(sele)){
    inter[sele] <-
      lubridate::interval(pmax(lubridate::int_start(int1[sele]),
                               lubridate::int_start(int2[sele])), 
                          pmin(lubridate::int_end(int1[sele]),
                               lubridate::int_end(int2[sele])))
  }
  inter
}  
```

测试如：

```{r}
d1 <- ymd(c("2018-01-15", "2018-01-18", "2018-01-25"))
d2 <- ymd(c("2018-01-21", "2018-01-23", "2018-01-30"))
din <- interval(d1, d2); din
int_intersect(rep(din[1], 2), din[2:3])
```

此自定义函数还可以进一步改成允许两个自变量长度不等的情形。

## 基本 R 软件的日期功能

### 生成日期和日期时间型数据

对 yyyy-mm-dd 或 yyyy/mm/dd 格式的数据，可以直接用 as.Date() 转换为Date 类型，如：

```{r}
x <- as.Date("1970-1-5"); x
as.numeric(x)
```

as.Date() 可以将多个日期字符串转换成 Date 类型，如

```{r}
as.Date(c("1970-1-5", "2017-9-12"))
```

对于非标准的格式，在 as.Date() 中可以增加一个 format 选项，其中用%Y表示四位数字的年，%m 表示月份数字，%d 表示日数字。如

```{r}
as.Date("1/5/1970", format="%m/%d/%Y")
```

用 as.POSIXct() 函数把年月日格式的日期转换为 R 的标准日期，没有时间部分就认为时间在午夜。如

```{r}
as.POSIXct(c('1998-03-16'))
as.POSIXct(c('1998/03/16'))
```

年月日中间的分隔符可以用减号也可以用正斜杠，但不能同时有减号又有斜杠。

待转换的日期时间字符串，可以是年月日之后隔一个空格以 “时: 分: 秒” 格式带有时间。如

```{r}
as.POSIXct('1998-03-16 13:15:45')
```

用 as.POSIXct() 可以同时转换多项日期时间，如

```{r}
as.POSIXct(c('1998-03-16 13:15:45', '2015-11-22 9:45:3'))
```

转换后的日期变量有 class 属性，取值为 POSIXct 与 POSIXt, 并带有一个tzone（时区）属性。

```{r}
x <- as.POSIXct(c('1998-03-16 13:15:45', '2015-11-22 9:45:3')) 
attributes(x)
```

在 as.POSIXct() 函数中用 format 参数指定一个日期格式。如

```{r}
as.POSIXct('3/13/15', format='%m/%d/%y')
```

如果日期仅有年和月，必须添加日（添加 01 为日即可）才能读入。比如用’1991-12’ 表示 1991 年 12 月，则如下程序将其读入为’1991-12-01’:

```{r}
as.POSIXct(paste('1991-12', '-01', sep=''), format='%Y-%m-%d')
```

又如

```{r}
old.lctime <- Sys.getlocale('LC_TIME')
Sys.setlocale('LC_TIME', 'C')
as.POSIXct(paste('01', 'DEC91', sep=''), format='%d%b%y')
Sys.setlocale('LC_TIME', old.lctime)
```

把'DEC91' 转换成了’1991-12-01’。

如果明确地知道时区，在 as.POSIXct() 和 as.POSIXlt() 中可以加选项tz= 字符串。选项 tz 的缺省值为空字符串，这一般对应于当前操作系统的默认时区。但是，有些操作系统和 R 版本不能使用默认值，这时可以为 tz 指定时区，比如北京时间可指定为 tz='Etc/GMT+8'。如

```{r}
as.POSIXct('1949-10-01', tz='Etc/GMT+8')
```

### 取出日期时间的组成值

把一个 R 日期时间值用 as.POSIXlt() 转换为 POSIXlt 类型，就可以用列表元素方法取出其组成的年、月、日、时、分、秒等数值。如

```{r}
x <- as.POSIXct('1998-03-16 13:15:45')
y <- as.POSIXlt(x)
cat(1900+y$year, y$mon+1, y$mday, y$hour, y$min, y$sec, '\n')
```

注意 year 要加 1900，mon 要加 1。另外，列表元素 wday 取值 1-6 时表示星期一到星期六，取值 0 时表示星期天。

对多个日期，as.POSIXlt() 会把它们转换成一个列表（列表类型稍后讲述），这时可以用列表元素 year, mon, mday 等取出日期成分。如

```{r}
x <- as.POSIXct(c('1998-03-16', '2015-11-22'))
as.POSIXlt(x)$year + 1900
```

### 日期计算

因为 Date 类型是用数值保存的，所以可以给日期加减一个整数，如：

```{r}
x <- as.Date("1970-1-5") 
x1 <- x + 10; x1
x2 <- x - 5; x2
```

所有的比较运算都适用于日期类型。可以给一个日期加减一定的秒数，如

```{r}
as.POSIXct(c('1998-03-16 13:15:45')) - 30
as.POSIXct(c('1998-03-16 13:15:45')) + 10
```

但是两个日期不能相加。
给一个日期加减一定天数，可以通过加减秒数实现，如

```{r}
as.POSIXct(c('1998-03-16 13:15:45')) + 3600*24*2
```

这个例子把日期推后了两天。
用 difftime(time1, time2, units='days') 计算 time1 减去 time2 的天数，如

```{r}
x <- as.POSIXct(c('1998-03-16', '2015-11-22'))
c(difftime(x[2], x[1], units='days'))
```

函数结果用 c() 包裹以转换为数值, 否则会带有单位。

调用 difftime() 时如果前两个自变量中含有时间部分，则间隔天数也会带有小数部分。如

```{r}
x <- as.POSIXct(c('1998-03-16 13:15:45', '2015-11-22 9:45:3')) 
c(difftime(x[2], x[1], units='days'))
```

difftime() 中 units 选项还可以取为 'secs', 'mins', 'hours' 等。

## 练习

设文件dates.csv中包含如下内容：

"出生日期","发病日期"

"1941/3/8","2007/1/1"

"1972/1/24","2007/1/1"

"1932/6/1","2007/1/1"

"1947/5/17","2007/1/1"

"1943/3/10","2007/1/1"

"1940/1/8","2007/1/1"

"1947/8/5","2007/1/1"

"2005/4/14","2007/1/1"

"1961/6/23","2007/1/2"

"1949/1/10","2007/1/2"

把这个文件读入为 R 数据框 dates.tab，运行如下程序定义 date1 和 date2变量:

```{r, eval=FALSE}
date1 <- dates.tab[,' 出生日期'] 
date2 <- dates.tab[,' 发病日期']
```

(1)	把 date1、date2 转换为 R 的 POSIXct 日期型。
(2)	求 date1 中的各个出生年。
(3)	计算发病时的年龄，以周岁论（过生日才算）。
(4)	把 date2 中发病年月转换为’monyy’ 格式，这里 mon 是如 FEB 这样英文三字母缩写，yy 是两数字的年份。
(5)	对诸如’FEB91’, ’OCT15’ 这样的年月数据，假设 00—20 表示 21 世纪年份，21—99 表示 20 实际年份。编写 R 函数，输入这样的字符型向量，返回相应的 POSIXct 格式日期，具体日期都取为相应月份的 1 号。这个习题和后两个习题可以预习函数部分来做。
(6)	对 R 的 POSIXct 日期，写函数转换成’FEB91’, ’OCT15’ 这样的年月表示，假设 00—20 表示 21 世纪年份，21—99 表示 20 实际年份。
(7)	给定两个 POSIXct 日期向量 birth 和 work，birth 为生日，work 是入职日期，编写 R 函数，返回相应的入职周岁整数值（不到生日时周岁值要减一）。

# 因子类型

## 因子

R 中用因子代表数据中分类变量, 如性别、省份、职业。有序因子代表有序量度，如打分结果，疾病严重程度等。

用 factor() 函数把字符型向量转换成因子，如

```{r}
x <- c(" 男", " 女", " 男", " 男", " 女") 
sex <- factor(x)
sex
attributes(sex)
```

因子有 class 属性，取值为"factor"，还有一个 levels(水平值) 属性，此属性可以用 levels() 函数访问，如

```{r}
levels(sex)
```

因子的 levels 属性可以看成是一个映射，把整数值 1,2,. . . 映射成这些水平值，因子在保存时会保存成整数值 1,2,. . . 等与水平值对应的编号。这样可以节省存储空间，在建模计算的程序中也比较有利于进行数学运算。

事实上，read.csv() 函数的默认操作会把输入文件的字符型列自动转换
成因子，这对于性别、职业、地名这样的列是合适的，但是对于姓名、日
期、详细地址这样的列则不合适。所以，在 read.csv() 调用中经常加选项stringsAsFactors=FALSE 选项禁止这样的自动转换，还可以用 colClasses选项逐个指定每列的类型。

用 as.numeric() 可以把因子转换为纯粹的整数值，如

```{r}
as.numeric(sex)
```

因为因子实际保存为整数值，所以对因子进行一些字符型操作可能导致错误。用as.character() 可以把因子转换成原来的字符型，如

```{r}
as.character(sex)
```

为了对因子执行字符型操作（如取子串），保险的做法是先用 as.character()函数强制转换为字符型。

factor() 函数的一般形式为

```{r, eval=FALSE}
factor(x, levels = sort(unique(x), na.last = TRUE),
      labels, exclude = NA, ordered = FALSE)
```

可以用选项 levels 自行指定各水平值, 不指定时由 x 的不同值来求得。可以用选项 labels 指定各水平的标签, 不指定时用各水平值的对应字符串。可以用 exclude 选项指定要转换为缺失值 (NA) 的元素值集合。如果指定了levels, 则当自变量 x 的某个元素等于第 j 个水平值时输出的因子对应元素值取整数 j, 如果该元素值没有出现在 levels 中则输出的因子对应元素值取NA。ordered 取真值时表示因子水平是有次序的 (按编码次序)。

在使用 factor() 函数定义因子时，如果知道自变量元素的所有可能取值，应尽可能使用 levels= 参数指定这些不同可能取值，这样，即使某个取值没有出现，此变量代表的含义和频数信息也是完整的。自己指定 levels= 的另一好处是可以按正确的次序显示因子的分类统计值。

因为一个因子的 levels 属性是该因子独有的，所以合并两个因子有可能造成错误。如

```{r}
li1 <- factor(c(' 男', ' 女')) 
li2 <- factor(c(' 男', ' 男')) 
c(li1, li2)
```

结果不再是因子。正确的做法是

```{r}
factor(c(as.character(li1), as.character(li2)))
```

即恢复成字符型后合并，然后再转换为因子。在合并两个数据框时也存在这样的问题。当然，如果在定义 li1 和 li2 时都用了 levels=c(' 男', ' 女')选项，c(li1, li2) 也能给出正确结果。

## table() 函数

用 table() 函数统计因子各水平的出现次数（称为频数或频率）。也可以对一般的向量统计每个不同元素的出现次数。如

```{r}
table(sex)
```

对一个变量用 table 函数计数的结果是一个特殊的有元素名的向量，元素名是自变量的不同取值，结果的元素值是对应的频数。单个因子或单个向量的频数结果可以用向量的下标访问方法取出单个频数或若干个频数的子集。

## tapply() 函数

可以按照因子分组然后每组计算另一变量的概括统计。如

```{r}
h <- c(165, 170, 168, 172, 159) 
tapply(h, sex, mean)
```

这里第一自变量 h 与与第二自变量 sex 是等长的，对应元素分别为同一人的身高和性别，tapply() 函数分男女两组计算了身高平均值。

## forcats 包的因子函数

```{r}
library(forcats)
```

在分类变量类数较多时，往往需要对因子水平另外排序、合并等，forcats 包提供了一些针对因子的方便函数。

forcats::fac_reorder() 可以根据不同因子水平分成的组中另一数值型变量的统计量值排序。如：

```{r}
set.seed(1)
fac <- sample(c("red", "green", "blue"), 30, replace=TRUE) 
fac <- factor(fac, levels=c("red", "green", "blue"))
x <- round(100*(10+rt(30,2)))
res1 <- tapply(x, fac, sd); res1
barplot(res1)
```

如果希望按照统计量次序对因子排序，可以用 forcats::fct_reorder() 函数，如

```{r}
fac2 <- fct_reorder(fac, x, sd) 
res2 <- tapply(x, fac2, sd) 
barplot(res2)
```

新的因子 fac2 的因子水平次序已经按照变量 x 的标准差从小到大排列。

有时在因子水平数较多时仅想将特定的一个或几个水平次序放到因子水平最前面，可以用 forcats::fct_relevel() 函数，如：

```{r}
levels(fac)
fac3 <- fct_relevel(fac, "blue"); levels(fac3)
```

fct_relevel() 第一个参数是要修改次序的因子，后续可以有多个字符型参数表示要提前的水平。

forcats::fct_reorder2(f, x, y) 也调整因子 f 的水平的次序，但是根据与每组中最大的 x 值相对应的 y 值大小调整次序，这样在作多个因子水平对应的曲线图时可以比较容易地区分多条曲线。

forcats::fct_recode() 可以修改每个水平的名称，如：

```{r}
fac4 <- fct_recode(
  fac,
  " 红"="red", " 绿"="green", " 蓝"="blue") 
table(fac4)
```

fct_recode() 在修改水平名时允许多个旧水平对应到一个新水平，从而合并原来的水平。如果合并很多，可以用 fct_collapse() 函数，如

```{r, eval=FALSE}
compf <- fct_collapse(
  comp,
" 其它"=c("", " 无名", " 无应答"), 
" 联想"=c(" 联想", " 联想集团"), 
" 百度"=c(" 百度", " 百度集团")
  )
```

如果某个因子频数少的水平很多，在统计时有过多水平不易展示主要的类别，可以用 forcats::fct_lump(f) 合并，缺省地从最少的类合并一直到 “其它” 类超过其它最小的类之前，可以用 n= 参数指定要保留多少个类。

## 练习

设文件class.csv中包含如下内容:

name,sex,age,height,weight

Alice,F,13,56.5,84

Becka,F,13,65.3,98

Gail,F,14,64.3,90

Karen,F,12,56.3,77

Kathy,F,12,59.8,84.5

Mary,F,15,66.5,112

Sandy,F,11,51.3,50.5

Sharon,F,15,62.5,112.5

Tammy,F,14,62.8,102.5

Alfred,M,14,69,112.5

Duke,M,14,63.5,102.5

Guido,M,15,67,133

James,M,12,57.3,83

Jeffrey,M,13,62.5,84

John,M,12,59,99.5

Philip,M,16,72,150

Robert,M,12,64.8,128

Thomas,M,11,57.5,85

William,M,15,66.5,112

用如下程序把该文件读入为 R 数据框 d.class, 其中的 sex 列已经自动转换为因子。取出其中的 sex 和 age 列到变量 sex 和 age 中

```{r, eval=FALSE}
d.class <- read.csv('class.csv', header=TRUE)
sex <- d.class[,'sex']
age <- d.class[,'age']
```

(1)	统计并显示列出 sex 的不同值频数；
(2)	分男女两组分别求年龄最大值；
(3)	把 sex 变量转换为一个新的因子，F 显示成 “Female”，M 显示成 “Male”。







